<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"></head><body class="c29"><p class="c13 c22 title" id="h.kt40mfbx5j5o"><span class="c25"></span></p><p class="c13 title" id="h.mvr5ou6c6ulv"><h1><span class="c25">Parallel Computing Lab - Assignment 4</span></p><p class="c13 title" id="h.nr9yfx6wsysy"><span class="c25">Mohd Ubaid Shaikh</span></p><p class="c13 title" id="h.nr9yfx6wsysy-1"><span class="c25">Roll no. 180001050</span></p><p class="c13 c22 title" id="h.tgy952e6y3ji"><span class="c20"></span></p><p class="c13 c22 title" id="h.x7fdft9xi41l"><span class="c20"></span></p><p class="c13 title" id="h.cry0bvz8zsfl"><span class="c25">Under the Guidance of</span></p><p class="c13 title" id="h.bj1k0pzhv4po"><span class="c25">Dr. Chandresh Kumar Maurya</span></p><p class="c30"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 465.00px; height: 115.00px;"><img alt="" src="images/image6.png" style="width: 465.00px; height: 115.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c13 title" id="h.nr9yfx6wsysy-2"><span class="c20">Computer Science and Engineering</span></p><p class="c2"><span class="c6"></span></p><p class="c2"><span class="c28"></span></p><p class="c13 title" id="h.ryce237aoo07"><span class="c20">April 23, 2021</span></p></h1><hr style="page-break-before:always;display:none;"><p class="c2"><span class="c6"></span></p><h1 class="c5" id="h.tu08rc38cy3a"><span class="c25">Genetic Algorithm Pseudo Code</span></h1><p class="c2"><span class="c18"></span></p><p class="c15"><span class="c18">create and initialize a population P(0);</span></p><p class="c15"><span class="c18">Repeat </span></p><p class="c15 c21"><span class="c27">Evaluate the fitness, f(x</span><span class="c27 c35">i</span><span class="c27">), for all x</span><span class="c27 c35">i</span><span class="c18">&nbsp;belonging to P(t);</span></p><p class="c15 c21"><span class="c18">Select fittest people from the population to become parents</span></p><p class="c15 c21"><span class="c18">Perform cross-over to produce offspring;</span></p><p class="c15 c21"><span class="c18">Perform mutation on offspring;</span></p><p class="c15 c21"><span class="c18">Select population P(t+1) of new generation;</span></p><p class="c15 c21"><span class="c18">Advance to the new generation, i.e. t = t+1;</span></p><p class="c15"><span class="c18">until max generation reached;</span></p><p class="c2"><span class="c18"></span></p><p class="c2"><span class="c32"></span></p><p class="c15"><span class="c33">Reference</span><span class="c6">: Computational Intelligence Class Slides</span></p><hr><p class="c2"><span class="c24"></span></p><p class="c15"><span class="c24">Each individual is represented by a permutation of city ids</span></p><p class="c15"><span class="c24">Fitness of an individual = 1 / (distance of the tour)</span></p><p class="c15"><span class="c24">For selecting parents from a population, I used the roulette wheel selection which is also known as fitness proportionate selection. Its basis is that individuals having higher fitness have higher chance of getting selected.</span></p><p class="c2"><span class="c6"></span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 321.39px; height: 252.09px;"><img alt="" src="images/image3.png" style="width: 321.39px; height: 252.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span>For crossover, I am using two point crossover, a randomly chosen subarray of the first parent is copied into the child and remaining genes are taken from the second such that cities are not duplicated. </span><hr style="page-break-before:always;display:none;"></p><h1 class="c5" id="h.qavoq4ppv4qx"><span class="c25">OpenMP parallel constructs used:</span></h1><p class="c2"><span class="c6"></span></p><a id="t.46b425a0af6c0218193c07586beec6acbb4e2072"></a><a id="t.0"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for reduction(max:best_fitness)</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; population.routes.size(); ++i){<br> &nbsp; &nbsp; &nbsp; computeFitness(population.routes[i]);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(population.routes[i].fitness &gt; best_fitness){ </span><span class="c3 c1">/* if fitness of current route is better that current best_fitness, then */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_fitness = population.routes[i].fitness; </span><span class="c3 c1">/* update best_fitness */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p><a id="t.214ff3ef04db03f59d18779ab251f615d4e02033"></a><a id="t.1"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; pop_size; ++i){<br> &nbsp; &nbsp; &nbsp; population.routes[i] = generateRandomRoute(i);<br> &nbsp; }</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p><a id="t.94c5e19f06835783c5b0b6ccaf9e3abb25e9a57b"></a><a id="t.2"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;k = </span><span class="c7 c1">0</span><span class="c0 c1">; k &lt; offsprings.size(); ++k){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;random = rand() % </span><span class="c7 c1">10000</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;rand_val = random / </span><span class="c7 c1">10000.0</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(rand_val &nbsp;&lt; mutation_rate){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;j = rand()%cities_cnt;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(offsprings[k].cities[i], offsprings[k].cities[j]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p><p class="c2"><span class="c6"></span></p><a id="t.770f0d8c801f7a94f908f59fa09ef7bae3ca6a9a"></a><a id="t.3"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = elite_size; i &lt; parents.size(); ++i){<br> &nbsp; &nbsp; &nbsp; Route child;<br> &nbsp; &nbsp; &nbsp; child.id = i;<br> &nbsp; &nbsp; &nbsp; performCrossOver(parents[i], parents[parents.size() - </span><span class="c7 c1">1</span><span class="c0 c1">&nbsp;- i], child);<br> &nbsp; &nbsp; &nbsp; new_generation[i] = child;<br> &nbsp; }</span></p></td></tr></tbody></table><p class="c22 c31"><span class="c1 c16"></span></p><a id="t.8cf7eb5c847a97dbd87a52a3c13b248fd9121a4f"></a><a id="t.4"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for reduction(+:fitness_sum)</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; people.size(); ++i)<br> &nbsp; &nbsp; &nbsp; fitness_sum += people[i].fitness;</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p><a id="t.72d1e327047c005914562e2a49dea80353365e63"></a><a id="t.5"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = elite_size; i &lt; people.size(); ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;num = rand()%</span><span class="c7 c1">10000</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;rand_num = num/</span><span class="c7 c1">10000.0</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;person:people){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(rand_num &lt; person.fitness){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fit_people[i] = person;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">break</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p><a id="t.7f173ff49f77a9e41a893b4fe23a4e97a12587cd"></a><a id="t.6"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#pragma omp parallel for</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;j = i + </span><span class="c7 c1">1</span><span class="c0 c1">; j &lt; cities_cnt; ++j){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;dist = </span><span class="c7 c1">sqrt</span><span class="c0 c1">(sqr(cities[i].x - cities[j].x) + sqr(cities[i].y - cities[j].y));<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graph[i][j] = dist;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graph[j][i] = dist;<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><p class="c2"><span class="c6"></span></p><h2 class="c26" id="h.ifoih3xpth8j"><span class="c8">Input:</span></h2><a id="t.77a4f37e54ab9039d259d538e4e3272f932c4548"></a><a id="t.7"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7">25</span><span class="c0"><br></span><span class="c7">171</span><span class="c0">&nbsp;</span><span class="c7">190</span><span class="c0"><br></span><span class="c7">135</span><span class="c0">&nbsp;</span><span class="c7">90</span><span class="c0"><br></span><span class="c7">25</span><span class="c0">&nbsp;</span><span class="c7">15</span><span class="c0"><br></span><span class="c7">137</span><span class="c0">&nbsp;</span><span class="c7">128</span><span class="c0"><br></span><span class="c7">147</span><span class="c0">&nbsp;</span><span class="c7">4</span><span class="c0"><br></span><span class="c7">25</span><span class="c0">&nbsp;</span><span class="c7">134</span><span class="c0"><br></span><span class="c7">8</span><span class="c0">&nbsp;</span><span class="c7">97</span><span class="c0"><br></span><span class="c7">98</span><span class="c0">&nbsp;</span><span class="c7">94</span><span class="c0"><br></span><span class="c7">114</span><span class="c0">&nbsp;</span><span class="c7">77</span><span class="c0"><br></span><span class="c7">138</span><span class="c0">&nbsp;</span><span class="c7">69</span><span class="c0"><br></span><span class="c7">90</span><span class="c0">&nbsp;</span><span class="c7">44</span><span class="c0"><br></span><span class="c7">158</span><span class="c0">&nbsp;</span><span class="c7">76</span><span class="c0"><br></span><span class="c7">139</span><span class="c0">&nbsp;</span><span class="c7">99</span><span class="c0"><br></span><span class="c7">93</span><span class="c0">&nbsp;</span><span class="c7">93</span><span class="c0"><br></span><span class="c7">97</span><span class="c0">&nbsp;</span><span class="c7">160</span><span class="c0"><br></span><span class="c7">151</span><span class="c0">&nbsp;</span><span class="c7">16</span><span class="c0"><br></span><span class="c7">106</span><span class="c0">&nbsp;</span><span class="c7">68</span><span class="c0"><br></span><span class="c7">84</span><span class="c0">&nbsp;</span><span class="c7">87</span><span class="c0"><br></span><span class="c7">16</span><span class="c0">&nbsp;</span><span class="c7">132</span><span class="c0"><br></span><span class="c7">136</span><span class="c0">&nbsp;</span><span class="c7">22</span><span class="c0"><br></span><span class="c7">156</span><span class="c0">&nbsp;</span><span class="c7">163</span><span class="c0"><br></span><span class="c7">60</span><span class="c0">&nbsp;</span><span class="c7">162</span><span class="c0"><br></span><span class="c7">57</span><span class="c0">&nbsp;</span><span class="c7">164</span><span class="c0"><br></span><span class="c7">41</span><span class="c0">&nbsp;</span><span class="c7">159</span><span class="c0"><br></span><span class="c7">29</span><span class="c0">&nbsp;</span><span class="c7">171</span></p></td></tr></tbody></table><hr style="page-break-before:always;display:none;"><p class="c2"><span class="c6"></span></p><h2 class="c26" id="h.31mailm4e8e9"><span class="c8">Output:</span></h2><p class="c15"><span class="c6">Population size = 1000, Max no. of iterations (generations) = 1000, No. of cities = 25</span></p><p class="c15"><span class="c6">For Serial,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">For Parallel,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">Speedup = Serial-time/Parallel-time = 13.435/10.648 = 1.2617</span></p><p class="c15"><span class="c6">Minimum value of distance = 787.00366</span></p><p class="c15"><span class="c6">As I have parallelized the iterations which depend on population size, better speed up is obtained when there is a bigger value of population size. For example:</span></p><p class="c15"><span class="c6">When, Population size = 10000, Max no. of iterations (generations) = 10, No. of cities = 25</span></p><p class="c15"><span class="c6">For Serial,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">For Parallel,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">Speed up = Serial-time/Parallel-time = 5.704 / 2.084 = 2.7370 which is very near to 3</span></p><p class="c2"><span class="c6"></span></p><p class="c15"><span class="c6">When, Population size = 10000, Max no. of iterations (generations) = 10, No. of cities = 100</span></p><p class="c15"><span class="c6">For Serial,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">For Parallel,</span></p><p class="c15"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c15"><span class="c6">Speed up = Serial-time/Parallel-time = 11.762 / 4.504 = 2.6115</span></p><hr style="page-break-before:always;display:none;"><h1 class="c5 c34" id="h.x4dpqosisl1u"><span class="c25"></span></h1><h1 class="c5" id="h.aa1w1m99n5ev"><span class="c25">Code:</span></h1><a id="t.7a83ca50ac1fbb4dd8ce536496b8a88a656aa87e"></a><a id="t.8"></a><table class="c10"><tbody><tr class="c23"><td class="c19" colspan="1" rowspan="1"><p class="c17"><span class="c7 c1">#include &lt;cstdio&gt; /* for using printf and scanf */</span><span class="c0 c1"><br></span><span class="c7 c1">#include &lt;cmath&gt; /* for using sqrt */</span><span class="c0 c1"><br></span><span class="c7 c1">#include &lt;vector&gt; /* for using vector */</span><span class="c0 c1"><br></span><span class="c7 c1">#include &lt;numeric&gt; /* for using iota function */</span><span class="c0 c1"><br></span><span class="c7 c1">#include &lt;ctime&gt; /* for using time(0) for seed srand() function */</span><span class="c0 c1"><br></span><span class="c7 c1">#include &lt;algorithm&gt; /* for using sort function */</span><span class="c0 c1"><br><br></span><span class="c7 c1">#define INF 999999 </span><span class="c3 c1">/* defining infinity to be 999999*/</span><span class="c0 c1"><br></span><span class="c7 c1">#define sqr(x) ((x) * (x)) </span><span class="c3 c1">/* it computes square of the given number */</span><span class="c0 c1"><br></span><span class="c4 c1">using</span><span class="c0 c1">&nbsp;</span><span class="c4 c1">namespace</span><span class="c0 c1">&nbsp;</span><span class="c7 c1">std</span><span class="c0 c1">;<br><br></span><span class="c3 c1">/* my genetic algorithm parameters */</span><span class="c0 c1"><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;elite_size = </span><span class="c7 c1">20</span><span class="c0 c1">; </span><span class="c3 c1">/* it indicates the no. of elite people that will be passed on to the next generation */</span><span class="c0 c1"><br></span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;mutation_rate = </span><span class="c7 c1">0.01</span><span class="c0 c1">; </span><span class="c3 c1">/* for introducing variation in our population by randomly swapping two cities in a route */</span><span class="c0 c1"><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;max_generations = </span><span class="c7 c1">1000</span><span class="c0 c1">; </span><span class="c3 c1">/* max no. of iterations of genetic algorithm */</span><span class="c0 c1"><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;pop_size = </span><span class="c7 c1">1000</span><span class="c0 c1">; </span><span class="c3 c1">/* population size of each generation */</span><span class="c0 c1"><br><br><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;cities_cnt; </span><span class="c3 c1">/* no. of cities that the salesman has to visit */</span><span class="c0 c1"><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;unique_id; </span><span class="c3 c1">/* used for alloting ids to routes in a population */</span><span class="c0 c1"><br></span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">float</span><span class="c0 c1">&gt;&gt; graph; </span><span class="c3 c1">/* for adjacency matrix representation of the distances between the cities */</span><span class="c0 c1"><br><br></span><span class="c3 c1">/* A structure for representing a city with id and (x, y) coordinates */</span><span class="c0 c1"><br></span><span class="c4 c1">struct</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">City</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;x, y, id;<br>};<br><br></span><span class="c3 c1">/* A structure for representing a route with id, fitness, its distance of travelling through the route and the permutaion of cities */</span><span class="c0 c1"><br></span><span class="c4 c1">struct</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">Route</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;id;<br> &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;fitness = </span><span class="c7 c1">0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;dist = </span><span class="c7 c1">0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">int</span><span class="c0 c1">&gt; cities; </span><span class="c3 c1">/* storing just the ids of the cities */</span><span class="c0 c1"><br>};<br><br></span><span class="c3 c1">/* A structure for representing a population. Every population has a generation number, several routes and a best route out of several routes*/</span><span class="c0 c1"><br></span><span class="c4 c1">struct</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">Population</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;gen_no; </span><span class="c3 c1">/* generation number */</span><span class="c0 c1"><br> &nbsp; Route best_route;<br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; routes;<br>};<br><br></span><span class="c3 c1">/* It computes fitness of the given route. */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">computeFitness</span><span class="c7 c1">(Route &amp;route)</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;dist = </span><span class="c7 c1">0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">1</span><span class="c0 c1">; i &lt;= cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; dist += graph[route.cities[i % cities_cnt]][route.cities[i - </span><span class="c7 c1">1</span><span class="c0 c1">]];<br> &nbsp; }<br> &nbsp; route.dist = dist;<br> &nbsp; route.fitness = </span><span class="c7 c1">1</span><span class="c0 c1">&nbsp;/ dist; </span><span class="c3 c1">/* fitness of a routes is defined to be the inverse of the distance of covering the route */</span><span class="c0 c1"><br>}<br><br></span><span class="c3 c1">/* It evaluates the fitness of each route in the given population. It also finds the route with the best fitness */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">evaluateFitness</span><span class="c7 c1">(Population &amp;population)</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;best_fitness = </span><span class="c7 c1">0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;r:population.routes){<br> &nbsp; &nbsp; &nbsp; computeFitness(r);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(r.fitness &gt; best_fitness){ </span><span class="c3 c1">/* if fitness of current route is better that current best_fitness, then */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_fitness = r.fitness; </span><span class="c3 c1">/* update best_fitness */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; population.best_route = r; </span><span class="c3 c1">/* and best route */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c3 c1">/* It generates a random route. It is used during the creation of 1st generation */</span><span class="c0 c1"><br>Route </span><span class="c14 c1">generateRandomRoute</span><span class="c7 c1">(</span><span class="c4 c1">int</span><span class="c7 c1">&nbsp;id)</span><span class="c0 c1">{<br> &nbsp; Route route;<br> &nbsp; route.id = id;<br> &nbsp; route.cities = </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">int</span><span class="c0 c1">&gt;(cities_cnt);<br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">int</span><span class="c0 c1">&gt; temp(cities_cnt);<br> &nbsp; iota(temp.begin(), temp.end(), </span><span class="c7 c1">0</span><span class="c0 c1">); </span><span class="c1 c3">/* fills the temp vector with values 0, 1, 2, ..., cities_cnt-1 */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;random_index = rand() % temp.size();<br> &nbsp; &nbsp; &nbsp; route.cities[i] = temp[random_index];<br> &nbsp; &nbsp; &nbsp; swap(temp[random_index], temp[temp.size() - </span><span class="c7 c1">1</span><span class="c0 c1">]);<br> &nbsp; &nbsp; &nbsp; temp.pop_back();<br> &nbsp; }<br> &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;route;<br>}<br><br></span><span class="c3 c1">/* It generates a random population. It is used for creating the 1st generation of population */</span><span class="c0 c1"><br>Population </span><span class="c14 c1">generateRandomPopulation</span><span class="c7 c1">(</span><span class="c4 c1">int</span><span class="c7 c1">&nbsp;gen_no, </span><span class="c4 c1">int</span><span class="c7 c1">&nbsp;pop_size)</span><span class="c0 c1">{<br> &nbsp; Population population;<br> &nbsp; population.gen_no = gen_no;<br> &nbsp; population.routes = </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt;(pop_size);<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c1 c4">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; pop_size; ++i){<br> &nbsp; &nbsp; &nbsp; population.routes[i] = generateRandomRoute(i);<br> &nbsp; }<br> &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;population;<br>}<br><br></span><span class="c3 c1">/* It is used to mutate the offspring passed as argument. For each route, each city<br>will be swapped with another city with a probability of mutation_rate */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">mutate</span><span class="c7 c1">(vector&lt;Route&gt; &amp;offsprings)</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;route:offsprings){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;random = rand() % </span><span class="c7 c1">10000</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;rand_val = random / </span><span class="c7 c1">10000.0</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(rand_val &nbsp;&lt; mutation_rate){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;j = rand()%cities_cnt;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(route.cities[i], route.cities[j]);<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c3 c1">/* It is used to shuffle the given parents. It is used to bring randomness in the order of parents.<br>Randomness is needed so that the creation of new generation is not affected by the order of parents */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">shuffle</span><span class="c7 c1">(vector&lt;Route&gt; &amp;parents)</span><span class="c0 c1">{<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; parents.size(); ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;index1 = rand() % parents.size();<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;index2 = rand() % parents.size();<br> &nbsp; &nbsp; &nbsp; swap(parents[index1], parents[index2]);<br> &nbsp; }<br>}<br><br></span><span class="c3 c1">/* It is used for perfoming crossover during breeding. It uses two point crossover.<br>First, a subarray of genes of first parent are taken and the rest of the genes are taken from the<br>second parent, such that cities do not get repeated */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">performCrossOver</span><span class="c7 c1">(Route p1, Route p2, Route &amp;child)</span><span class="c0 c1">{<br><br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;geneA = rand()%cities_cnt;<br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;geneB = rand()%cities_cnt;<br> &nbsp;<br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;startGene = min(geneA, geneB); </span><span class="c3 c1">/* startGene and endGene correspond to the starting index and */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;endGene = max(geneA, geneB); </span><span class="c3 c1">/* ending index of the subarray to be taken from parent 1 */</span><span class="c0 c1"><br><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = startGene; i &lt; endGene; ++i){<br> &nbsp; &nbsp; &nbsp; child.cities.push_back(p1.cities[i]);<br> &nbsp; }<br><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;city:p2.cities){ </span><span class="c3 c1">/* fill the empty places with cities from 2nd parent, such that no city gets repeated */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(find(child.cities.begin(), child.cities.end(), city) == child.cities.end()){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child.cities.push_back(city);<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br>}<br><br></span><span class="c3 c1">/* It performs Breeding. First, elite_size number of top parents are passed on/promoted to the next generation. <br>Then parents order is shuffled to bring some randomness. The pop_size - elite_size no. of childs are created using crossover operation*/</span><span class="c0 c1"><br></span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; performBreeding(</span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; &amp;parents){<br> &nbsp; unique_id = </span><span class="c7 c1">0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; new_generation;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; elite_size; ++i){ </span><span class="c3 c1">/* pass on the elite people to the next generation */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; new_generation.push_back(parents[i]);<br> &nbsp; &nbsp; &nbsp; new_generation.back().id = unique_id++;<br> &nbsp; }<br> &nbsp; shuffle(parents);<br><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; parents.size() - elite_size; ++i){<br> &nbsp; &nbsp; &nbsp; Route child;<br> &nbsp; &nbsp; &nbsp; child.id = unique_id++;<br> &nbsp; &nbsp; &nbsp; performCrossOver(parents[i], parents[parents.size() - </span><span class="c7 c1">1</span><span class="c0 c1">&nbsp;- i], child);<br> &nbsp; &nbsp; &nbsp; new_generation.push_back(child);<br> &nbsp; }<br> &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;new_generation;<br>}<br><br></span><span class="c3 c1">/* It selects the fittest people to become parents. The basis rule for selecting people is that<br>people having higher fitness value have higher chances of becoming parents */</span><span class="c0 c1"><br></span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; selectFittest(</span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; people){<br> &nbsp; sort(people.begin(), people.end(), [](Route &amp;a, Route &amp;b){ </span><span class="c3 c1">/* first, we arrange people in descending order of fitness */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;a.fitness &gt; b.fitness;<br> &nbsp; });<br><br> &nbsp; </span><span class="c3 c1">/* now, we compute cumulative fitness for each people */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;fitness_sum = </span><span class="c7 c1">0.0</span><span class="c0 c1">, prev_probability = </span><span class="c7 c1">0.0</span><span class="c0 c1">;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;r:people)<br> &nbsp; &nbsp; &nbsp; fitness_sum += r.fitness;<br> &nbsp;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;r:people){<br> &nbsp; &nbsp; &nbsp; r.fitness = prev_probability + (r.fitness / fitness_sum);<br> &nbsp; &nbsp; &nbsp; prev_probability = r.fitness;<br> &nbsp; }<br><br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; fit_people(people.size()); </span><span class="c3 c1">/* declaring array for storing fit peopel */</span><span class="c0 c1"><br> &nbsp;<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; elite_size; ++i){ </span><span class="c3 c1">/* elite_size of top people will be selected to become parents */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; fit_people[i] = people[i];<br> &nbsp; }<br><br> &nbsp; </span><span class="c3 c1">/* remaining number of people will be selected using routlette wheel selection (fitness proportionate selection) */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = elite_size; i &lt; people.size(); ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;num = rand()%</span><span class="c7 c1">10000</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;rand_num = num/</span><span class="c7 c1">10000.0</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;person:people){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">if</span><span class="c0 c1">(rand_num &lt; person.fitness){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fit_people[i] = person;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">break</span><span class="c0 c1">;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br> &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;fit_people;<br>}<br><br></span><span class="c3 c1">/* It prints the data of population passed as argument */</span><span class="c0 c1"><br></span><span class="c4 c1">void</span><span class="c0 c1">&nbsp;</span><span class="c1 c14">printPopulation</span><span class="c7 c1">(Population population)</span><span class="c0 c1">{<br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;The generation %d is as follows:\n&quot;</span><span class="c0 c1">, population.gen_no);<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;r:population.routes){<br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;%d: &quot;</span><span class="c0 c1">, r.id);<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;city:r.cities){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;%d &quot;</span><span class="c0 c1">, city);<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;| dist = %f\n&quot;</span><span class="c0 c1">, r.dist);<br> &nbsp; }<br>}<br><br></span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;</span><span class="c14 c1">main</span><span class="c7 c1">()</span><span class="c0 c1">{<br> &nbsp; </span><span class="c7 c1">scanf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;%d&quot;</span><span class="c0 c1">, &amp;cities_cnt); </span><span class="c3 c1">/* take the number of cities as input */</span><span class="c0 c1"><br> &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;City&gt; cities(cities_cnt); </span><span class="c3 c1">/* declaring a vector of cities to store the (x, y) coordinates of cities given as input */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; cities[i].id = i;<br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">scanf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;%d %d&quot;</span><span class="c0 c1">, &amp;cities[i].x, &amp;cities[i].y);<br> &nbsp; }<br><br> &nbsp; </span><span class="c3 c1">/* allocating cities_cnt x cities_cnt space for adjacency matrix representation of the distances among the given cities*/</span><span class="c0 c1"><br> &nbsp; graph = </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">float</span><span class="c0 c1">&gt;&gt;(cities_cnt, </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;</span><span class="c4 c1">float</span><span class="c0 c1">&gt; (cities_cnt, INF));<br> &nbsp;<br> &nbsp; </span><span class="c3 c1">/* computing distances among the cities and filling our adjacency matrix */</span><span class="c0 c1"><br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;i = </span><span class="c7 c1">0</span><span class="c0 c1">; i &lt; cities_cnt; ++i){<br> &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">int</span><span class="c0 c1">&nbsp;j = i + </span><span class="c7 c1">1</span><span class="c0 c1">; j &lt; cities_cnt; ++j){<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c1">float</span><span class="c0 c1">&nbsp;dist = </span><span class="c7 c1">sqrt</span><span class="c0 c1">(sqr(cities[i].x - cities[j].x) + sqr(cities[i].y - cities[j].y));<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graph[i][j] = dist;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graph[j][i] = dist;<br> &nbsp; &nbsp; &nbsp; }<br> &nbsp; }<br><br> &nbsp; srand(time(</span><span class="c7 c1">0</span><span class="c0 c1">)); </span><span class="c3 c1">/* seeding our rand() function */</span><span class="c0 c1"><br> &nbsp; Population population = generateRandomPopulation(</span><span class="c7 c1">1</span><span class="c0 c1">, pop_size); </span><span class="c3 c1">/* generate the first population */</span><span class="c0 c1"><br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;Starting Genetic Algorithm...\n&quot;</span><span class="c0 c1">);<br> &nbsp; </span><span class="c4 c1">while</span><span class="c0 c1">(population.gen_no &lt;= max_generations){<br> &nbsp; &nbsp; &nbsp; evaluateFitness(population); </span><span class="c3 c1">/* evaluate the fitness, f(x), for all x belonging to current generation; */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;Gen %d: Best Fitness = %f, Best Distance = %f\n&quot;</span><span class="c0 c1">, population.gen_no, population.best_route.fitness, population.best_route.dist);<br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; fittest_people = selectFittest(population.routes); </span><span class="c3 c1">/* select pop_size routes for becoming parent */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">vector</span><span class="c0 c1">&lt;Route&gt; offsprings = performBreeding(fittest_people); </span><span class="c3 c1">/* perform cross-over among the selected parents to produce offspring; */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; mutate(offsprings); </span><span class="c3 c1">/* mutate the offsprings with probability as mutation_rate */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; population.routes = offsprings; </span><span class="c3 c1">/* update population; */</span><span class="c0 c1"><br> &nbsp; &nbsp; &nbsp; population.gen_no += </span><span class="c7 c1">1</span><span class="c0 c1">; </span><span class="c3 c1">/* advance to the next generation */</span><span class="c0 c1"><br> &nbsp; }<br><br> &nbsp; evaluateFitness(population); </span><span class="c3 c1">/* evaluate the fitness, f(x), for all x belonging to current generation; */</span><span class="c0 c1"><br><br> &nbsp; </span><span class="c3 c1">/* print the final results */</span><span class="c0 c1"><br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;\nAfter %d Generations,\n&quot;</span><span class="c0 c1">, population.gen_no);<br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;Best Fitness obtained = %f\n&quot;</span><span class="c0 c1">, population.best_route.fitness);<br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;Best Distance obtained = %f\n&quot;</span><span class="c0 c1">, population.best_route.dist);<br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;Best Fitness Route is as follows:\n&quot;</span><span class="c0 c1">);<br> &nbsp; </span><span class="c4 c1">for</span><span class="c0 c1">(</span><span class="c4 c1">auto</span><span class="c0 c1">&nbsp;&amp;city:population.best_route.cities){<br> &nbsp; &nbsp; &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c1 c9">&quot;%d &quot;</span><span class="c0 c1">, city);<br> &nbsp; }<br> &nbsp; </span><span class="c7 c1">printf</span><span class="c0 c1">(</span><span class="c9 c1">&quot;\n&quot;</span><span class="c0 c1">);<br> &nbsp; </span><span class="c4 c1">return</span><span class="c0 c1">&nbsp;</span><span class="c7 c1">0</span><span class="c0 c1">;<br>}</span></p></td></tr></tbody></table><p class="c2"><span class="c6"></span></p></body></html>